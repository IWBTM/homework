

## chapter 11

```python
class Solution:
    def minDistance(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """
        n = len(word1)
        m = len(word2)
        
        # 有一个字符串为空串
        if n * m == 0:
            return n + m
        
        # DP 数组
        D = [ [0] * (m + 1) for _ in range(n + 1)]
        
        # 边界状态初始化
        for i in range(n + 1):
            D[i][0] = i
        for j in range(m + 1):
            D[0][j] = j
        
        # 计算所有 DP 值
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                left = D[i - 1][j] + 1
                down = D[i][j - 1] + 1
                left_down = D[i - 1][j - 1] 
                if word1[i - 1] != word2[j - 1]:
                    left_down += 1
                D[i][j] = min(left, down, left_down)
        
        return D[n][m]
```

## chapter 12

a. Always give the highest denomination coin that you can without going over. Then, repeat this process until the amount of remaining change drops to 00.

b. Given an optimal solution $(x_0, x_1, \dots, x_k)$ where $x_i$ indicates the number of coins of denomination $c_i$ . We will first show that we must have $ x_i < c $ for every $i < k$. Suppose that we had some $x_i \ge c$, then, we could decrease $ x_i $by $c$ and increase $x_{i + 1}$ by 1. This collection of coins has the same value and has $ c − 1$ fewer coins, so the original solution must of been non-optimal. This configuration of coins is exactly the same as you would get if you kept greedily picking the largest coin possible. This is because to get a total value of $V$, you would pick $x_k = \lfloor V c^{−k} \rfloor$ and for $i < k$, $x_i\lfloor (V\mod c^{i + 1})c^{-i} \rfloor$. This is the only solution that satisfies the property that there aren't more than c*c* of any but the largest denomination because the coin amounts are a base *c* representation of V mod $c^k$.

c. Let the coin denominations be \{1, 3, 4\}, and the value to make change for be 6. The greedy solution would result in the collection of coins {1,1,4} but the optimal solution would be \{3, 3\}.

d. See algorithm $\text{MAKE-CHANGE}(S, v)$ which does a dynamic programming solution. Since the first for loop runs *n* times, and the inner for loop runs *k* times, and the later while loop runs at most *n* times, the total running time is O*(*nk*).

## chapter 13





















